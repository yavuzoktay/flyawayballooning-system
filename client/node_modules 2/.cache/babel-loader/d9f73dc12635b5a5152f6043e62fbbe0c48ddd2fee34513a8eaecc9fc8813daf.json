{"ast":null,"code":"import * as React from 'react';\nimport useForkRef from '@mui/utils/useForkRef';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useId from '@mui/utils/useId';\nimport { getSectionValueNow, getSectionValueText, parseSelectedSections } from \"./useField.utils.js\";\nimport { getActiveElement } from \"../../utils/utils.js\";\nimport { usePickersTranslations } from \"../../../hooks/usePickersTranslations.js\";\nimport { useUtils } from \"../useUtils.js\";\nexport const useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);\n  const translations = usePickersTranslations();\n  const utils = useUtils();\n  const id = useId();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const selection = document.getSelection();\n      if (!selection) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {\n        return;\n      }\n      const range = new window.Range();\n      let target;\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = getActiveElement(document);\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: function () {\n      let newSelectedSections = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (!sectionListRef.current ||\n      // if the field is already focused, we don't need to focus it again\n      interactions.getActiveSectionIndexFromDOM() != null) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = getActiveElement(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = useEventCallback(function (event) {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    onClick === null || onClick === void 0 || onClick(event, ...args);\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += \"\".concat(section.startSeparator).concat(section.value || section.placeholder).concat(section.endSeparator).length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = useEventCallback(event => {\n    var _target$textContent;\n    onInput === null || onInput === void 0 || onInput(event);\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = (_target$textContent = target.textContent) !== null && _target$textContent !== void 0 ? _target$textContent : '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => \"\".concat(section.startSeparator).concat(section.value || section.placeholder).concat(section.endSeparator)).join('');\n    interactions.syncSelectionToDOM();\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = useEventCallback(event => {\n    onPaste === null || onPaste === void 0 || onPaste(event);\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = useEventCallback(function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    onFocus === null || onFocus === void 0 || onFocus(...args);\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = useEventCallback(function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    onBlur === null || onBlur === void 0 || onBlur(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const activeElement = getActiveElement(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = useEventCallback(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = useEventCallback(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = useEventCallback(event => {\n    var _target$textContent2;\n    if (!sectionListRef.current) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = (_target$textContent2 = target.textContent) !== null && _target$textContent2 !== void 0 ? _target$textContent2 : '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  useEnhancedEffect(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: \"\".concat(id, \"-\").concat(section.type),\n          'aria-labelledby': \"\".concat(id, \"-\").concat(section.type),\n          'aria-readonly': readOnly,\n          'aria-valuenow': getSectionValueNow(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = useEventCallback(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp !== null && focusedProp !== void 0 ? focusedProp : focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};","map":{"version":3,"names":["React","useForkRef","useEventCallback","useEnhancedEffect","useId","getSectionValueNow","getSectionValueText","parseSelectedSections","getActiveElement","usePickersTranslations","useUtils","useFieldV7TextField","params","internalProps","disabled","readOnly","forwardedProps","sectionListRef","inSectionListRef","onBlur","onClick","onFocus","onInput","onPaste","focused","focusedProp","autoFocus","fieldValueManager","applyCharacterEditing","resetCharacterQuery","setSelectedSections","parsedSelectedSections","state","clearActiveSection","clearValue","updateSectionValue","updateValueFromValueStr","sectionOrder","areAllSectionsEmpty","sectionsValueBoundaries","useRef","handleSectionListRef","translations","utils","id","setFocused","useState","interactions","useMemo","syncSelectionToDOM","current","selection","document","getSelection","rangeCount","getRoot","contains","getRangeAt","startContainer","removeAllRanges","blur","range","window","Range","target","section","sections","type","getSectionContainer","getSectionContent","selectNodeContents","focus","addRange","getActiveSectionIndexFromDOM","activeElement","getSectionIndexFromDOMElement","focusField","newSelectedSections","arguments","length","undefined","newParsedSelectedSections","newActiveSectionIndex","isFieldFocused","revertDOMSectionChange","sectionIndex","innerHTML","value","placeholder","handleContainerClick","event","isDefaultPrevented","_len","args","Array","_key","setTimeout","cursorPosition","startOffset","startIndex","cursorOnStartOfSection","concat","startSeparator","endSeparator","hasClickedOnASection","handleContainerInput","_target$textContent","keyPressed","textContent","map","join","charCodeAt","handleContainerPaste","preventDefault","pastedValue","clipboardData","getData","handleContainerFocus","_len2","_key2","isFocusInsideASection","handleContainerBlur","_len3","_key3","shouldBlur","getInputContainerClickHandler","handleInputContentMouseUp","getInputContentFocusHandler","handleInputContentPaste","activeSection","lettersOnly","test","digitsOnly","digitsAndLetterOnly","isValidPastedValue","contentType","newSectionValue","shouldGoToNextSection","handleInputContentDragOver","dataTransfer","dropEffect","handleInputContentInput","_target$textContent2","inputType","nativeEvent","domElement","sectionBoundaries","reduce","acc","next","currentDate","format","isContainerEditable","elements","index","isEditable","container","content","tabIndex","contentEditable","role","minimum","maximum","empty","spellCheck","autoCapitalize","autoCorrect","parseInt","version","children","onDragOver","onMouseUp","inputMode","before","after","handleValueStrChange","valueStr","getV7HiddenInputValueFromSections","useEffect","Error","returnedValue","enableAccessibleFieldDOMStructure","onChange"],"sources":["/Users/yavuzoktay/Documents/FlyAwayBallooning/flyawayballooning-system-backend/client/node_modules/@mui/x-date-pickers/internals/hooks/useField/useFieldV7TextField.js"],"sourcesContent":["import * as React from 'react';\nimport useForkRef from '@mui/utils/useForkRef';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport useId from '@mui/utils/useId';\nimport { getSectionValueNow, getSectionValueText, parseSelectedSections } from \"./useField.utils.js\";\nimport { getActiveElement } from \"../../utils/utils.js\";\nimport { usePickersTranslations } from \"../../../hooks/usePickersTranslations.js\";\nimport { useUtils } from \"../useUtils.js\";\nexport const useFieldV7TextField = params => {\n  const {\n    internalProps: {\n      disabled,\n      readOnly = false\n    },\n    forwardedProps: {\n      sectionListRef: inSectionListRef,\n      onBlur,\n      onClick,\n      onFocus,\n      onInput,\n      onPaste,\n      focused: focusedProp,\n      autoFocus = false\n    },\n    fieldValueManager,\n    applyCharacterEditing,\n    resetCharacterQuery,\n    setSelectedSections,\n    parsedSelectedSections,\n    state,\n    clearActiveSection,\n    clearValue,\n    updateSectionValue,\n    updateValueFromValueStr,\n    sectionOrder,\n    areAllSectionsEmpty,\n    sectionsValueBoundaries\n  } = params;\n  const sectionListRef = React.useRef(null);\n  const handleSectionListRef = useForkRef(inSectionListRef, sectionListRef);\n  const translations = usePickersTranslations();\n  const utils = useUtils();\n  const id = useId();\n  const [focused, setFocused] = React.useState(false);\n  const interactions = React.useMemo(() => ({\n    syncSelectionToDOM: () => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const selection = document.getSelection();\n      if (!selection) {\n        return;\n      }\n      if (parsedSelectedSections == null) {\n        // If the selection contains an element inside the field, we reset it.\n        if (selection.rangeCount > 0 && sectionListRef.current.getRoot().contains(selection.getRangeAt(0).startContainer)) {\n          selection.removeAllRanges();\n        }\n        if (focused) {\n          sectionListRef.current.getRoot().blur();\n        }\n        return;\n      }\n\n      // On multi input range pickers we want to update selection range only for the active input\n      if (!sectionListRef.current.getRoot().contains(getActiveElement(document))) {\n        return;\n      }\n      const range = new window.Range();\n      let target;\n      if (parsedSelectedSections === 'all') {\n        target = sectionListRef.current.getRoot();\n      } else {\n        const section = state.sections[parsedSelectedSections];\n        if (section.type === 'empty') {\n          target = sectionListRef.current.getSectionContainer(parsedSelectedSections);\n        } else {\n          target = sectionListRef.current.getSectionContent(parsedSelectedSections);\n        }\n      }\n      range.selectNodeContents(target);\n      target.focus();\n      selection.removeAllRanges();\n      selection.addRange(range);\n    },\n    getActiveSectionIndexFromDOM: () => {\n      const activeElement = getActiveElement(document);\n      if (!activeElement || !sectionListRef.current || !sectionListRef.current.getRoot().contains(activeElement)) {\n        return null;\n      }\n      return sectionListRef.current.getSectionIndexFromDOMElement(activeElement);\n    },\n    focusField: (newSelectedSections = 0) => {\n      if (!sectionListRef.current ||\n      // if the field is already focused, we don't need to focus it again\n      interactions.getActiveSectionIndexFromDOM() != null) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      setFocused(true);\n      sectionListRef.current.getSectionContent(newParsedSelectedSections).focus();\n    },\n    setSelectedSections: newSelectedSections => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const newParsedSelectedSections = parseSelectedSections(newSelectedSections, state.sections);\n      const newActiveSectionIndex = newParsedSelectedSections === 'all' ? 0 : newParsedSelectedSections;\n      setFocused(newActiveSectionIndex !== null);\n      setSelectedSections(newSelectedSections);\n    },\n    isFieldFocused: () => {\n      const activeElement = getActiveElement(document);\n      return !!sectionListRef.current && sectionListRef.current.getRoot().contains(activeElement);\n    }\n  }), [parsedSelectedSections, setSelectedSections, state.sections, focused]);\n\n  /**\n   * If a section content has been updated with a value we don't want to keep,\n   * Then we need to imperatively revert it (we can't let React do it because the value did not change in his internal representation).\n   */\n  const revertDOMSectionChange = useEventCallback(sectionIndex => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const section = state.sections[sectionIndex];\n    sectionListRef.current.getSectionContent(sectionIndex).innerHTML = section.value || section.placeholder;\n    interactions.syncSelectionToDOM();\n  });\n  const handleContainerClick = useEventCallback((event, ...args) => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call of `handleContainerClick` is actually intended, or a side effect.\n    if (event.isDefaultPrevented() || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    onClick?.(event, ...args);\n    if (parsedSelectedSections === 'all') {\n      setTimeout(() => {\n        const cursorPosition = document.getSelection().getRangeAt(0).startOffset;\n        if (cursorPosition === 0) {\n          setSelectedSections(sectionOrder.startIndex);\n          return;\n        }\n        let sectionIndex = 0;\n        let cursorOnStartOfSection = 0;\n        while (cursorOnStartOfSection < cursorPosition && sectionIndex < state.sections.length) {\n          const section = state.sections[sectionIndex];\n          sectionIndex += 1;\n          cursorOnStartOfSection += `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`.length;\n        }\n        setSelectedSections(sectionIndex - 1);\n      });\n    } else if (!focused) {\n      setFocused(true);\n      setSelectedSections(sectionOrder.startIndex);\n    } else {\n      const hasClickedOnASection = sectionListRef.current.getRoot().contains(event.target);\n      if (!hasClickedOnASection) {\n        setSelectedSections(sectionOrder.startIndex);\n      }\n    }\n  });\n  const handleContainerInput = useEventCallback(event => {\n    onInput?.(event);\n    if (!sectionListRef.current || parsedSelectedSections !== 'all') {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    sectionListRef.current.getRoot().innerHTML = state.sections.map(section => `${section.startSeparator}${section.value || section.placeholder}${section.endSeparator}`).join('');\n    interactions.syncSelectionToDOM();\n    if (keyPressed.length === 0 || keyPressed.charCodeAt(0) === 10) {\n      resetCharacterQuery();\n      clearValue();\n      setSelectedSections('all');\n    } else if (keyPressed.length > 1) {\n      updateValueFromValueStr(keyPressed);\n    } else {\n      if (parsedSelectedSections === 'all') {\n        setSelectedSections(0);\n      }\n      applyCharacterEditing({\n        keyPressed,\n        sectionIndex: 0\n      });\n    }\n  });\n  const handleContainerPaste = useEventCallback(event => {\n    onPaste?.(event);\n    if (readOnly || parsedSelectedSections !== 'all') {\n      event.preventDefault();\n      return;\n    }\n    const pastedValue = event.clipboardData.getData('text');\n    event.preventDefault();\n    resetCharacterQuery();\n    updateValueFromValueStr(pastedValue);\n  });\n  const handleContainerFocus = useEventCallback((...args) => {\n    onFocus?.(...args);\n    if (focused || !sectionListRef.current) {\n      return;\n    }\n    setFocused(true);\n    const isFocusInsideASection = sectionListRef.current.getSectionIndexFromDOMElement(getActiveElement(document)) != null;\n    if (!isFocusInsideASection) {\n      setSelectedSections(sectionOrder.startIndex);\n    }\n  });\n  const handleContainerBlur = useEventCallback((...args) => {\n    onBlur?.(...args);\n    setTimeout(() => {\n      if (!sectionListRef.current) {\n        return;\n      }\n      const activeElement = getActiveElement(document);\n      const shouldBlur = !sectionListRef.current.getRoot().contains(activeElement);\n      if (shouldBlur) {\n        setFocused(false);\n        setSelectedSections(null);\n      }\n    });\n  });\n  const getInputContainerClickHandler = useEventCallback(sectionIndex => event => {\n    // The click event on the clear button would propagate to the input, trigger this handler and result in a wrong section selection.\n    // We avoid this by checking if the call to this function is actually intended, or a side effect.\n    if (event.isDefaultPrevented()) {\n      return;\n    }\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentMouseUp = useEventCallback(event => {\n    // Without this, the browser will remove the selected when clicking inside an already-selected section.\n    event.preventDefault();\n  });\n  const getInputContentFocusHandler = useEventCallback(sectionIndex => () => {\n    setSelectedSections(sectionIndex);\n  });\n  const handleInputContentPaste = useEventCallback(event => {\n    // prevent default to avoid the input `onInput` handler being called\n    event.preventDefault();\n    if (readOnly || disabled || typeof parsedSelectedSections !== 'number') {\n      return;\n    }\n    const activeSection = state.sections[parsedSelectedSections];\n    const pastedValue = event.clipboardData.getData('text');\n    const lettersOnly = /^[a-zA-Z]+$/.test(pastedValue);\n    const digitsOnly = /^[0-9]+$/.test(pastedValue);\n    const digitsAndLetterOnly = /^(([a-zA-Z]+)|)([0-9]+)(([a-zA-Z]+)|)$/.test(pastedValue);\n    const isValidPastedValue = activeSection.contentType === 'letter' && lettersOnly || activeSection.contentType === 'digit' && digitsOnly || activeSection.contentType === 'digit-with-letter' && digitsAndLetterOnly;\n    if (isValidPastedValue) {\n      resetCharacterQuery();\n      updateSectionValue({\n        activeSection,\n        newSectionValue: pastedValue,\n        shouldGoToNextSection: true\n      });\n    }\n    // If the pasted value corresponds to a single section, but not the expected type, we skip the modification\n    else if (!lettersOnly && !digitsOnly) {\n      resetCharacterQuery();\n      updateValueFromValueStr(pastedValue);\n    }\n  });\n  const handleInputContentDragOver = useEventCallback(event => {\n    event.preventDefault();\n    event.dataTransfer.dropEffect = 'none';\n  });\n  const handleInputContentInput = useEventCallback(event => {\n    if (!sectionListRef.current) {\n      return;\n    }\n    const target = event.target;\n    const keyPressed = target.textContent ?? '';\n    const sectionIndex = sectionListRef.current.getSectionIndexFromDOMElement(target);\n    const section = state.sections[sectionIndex];\n    if (readOnly || !sectionListRef.current) {\n      revertDOMSectionChange(sectionIndex);\n      return;\n    }\n    if (keyPressed.length === 0) {\n      if (section.value === '') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      const inputType = event.nativeEvent.inputType;\n      if (inputType === 'insertParagraph' || inputType === 'insertLineBreak') {\n        revertDOMSectionChange(sectionIndex);\n        return;\n      }\n      resetCharacterQuery();\n      clearActiveSection();\n      return;\n    }\n    applyCharacterEditing({\n      keyPressed,\n      sectionIndex\n    });\n\n    // The DOM value needs to remain the one React is expecting.\n    revertDOMSectionChange(sectionIndex);\n  });\n  useEnhancedEffect(() => {\n    if (!focused || !sectionListRef.current) {\n      return;\n    }\n    if (parsedSelectedSections === 'all') {\n      sectionListRef.current.getRoot().focus();\n    } else if (typeof parsedSelectedSections === 'number') {\n      const domElement = sectionListRef.current.getSectionContent(parsedSelectedSections);\n      if (domElement) {\n        domElement.focus();\n      }\n    }\n  }, [parsedSelectedSections, focused]);\n  const sectionBoundaries = React.useMemo(() => {\n    return state.sections.reduce((acc, next) => {\n      acc[next.type] = sectionsValueBoundaries[next.type]({\n        currentDate: null,\n        contentType: next.contentType,\n        format: next.format\n      });\n      return acc;\n    }, {});\n  }, [sectionsValueBoundaries, state.sections]);\n  const isContainerEditable = parsedSelectedSections === 'all';\n  const elements = React.useMemo(() => {\n    return state.sections.map((section, index) => {\n      const isEditable = !isContainerEditable && !disabled && !readOnly;\n      return {\n        container: {\n          'data-sectionindex': index,\n          onClick: getInputContainerClickHandler(index)\n        },\n        content: {\n          tabIndex: isContainerEditable || index > 0 ? -1 : 0,\n          contentEditable: !isContainerEditable && !disabled && !readOnly,\n          role: 'spinbutton',\n          id: `${id}-${section.type}`,\n          'aria-labelledby': `${id}-${section.type}`,\n          'aria-readonly': readOnly,\n          'aria-valuenow': getSectionValueNow(section, utils),\n          'aria-valuemin': sectionBoundaries[section.type].minimum,\n          'aria-valuemax': sectionBoundaries[section.type].maximum,\n          'aria-valuetext': section.value ? getSectionValueText(section, utils) : translations.empty,\n          'aria-label': translations[section.type],\n          'aria-disabled': disabled,\n          spellCheck: isEditable ? false : undefined,\n          autoCapitalize: isEditable ? 'off' : undefined,\n          autoCorrect: isEditable ? 'off' : undefined,\n          [parseInt(React.version, 10) >= 17 ? 'enterKeyHint' : 'enterkeyhint']: isEditable ? 'next' : undefined,\n          children: section.value || section.placeholder,\n          onInput: handleInputContentInput,\n          onPaste: handleInputContentPaste,\n          onFocus: getInputContentFocusHandler(index),\n          onDragOver: handleInputContentDragOver,\n          onMouseUp: handleInputContentMouseUp,\n          inputMode: section.contentType === 'letter' ? 'text' : 'numeric'\n        },\n        before: {\n          children: section.startSeparator\n        },\n        after: {\n          children: section.endSeparator\n        }\n      };\n    });\n  }, [state.sections, getInputContentFocusHandler, handleInputContentPaste, handleInputContentDragOver, handleInputContentInput, getInputContainerClickHandler, handleInputContentMouseUp, disabled, readOnly, isContainerEditable, translations, utils, sectionBoundaries, id]);\n  const handleValueStrChange = useEventCallback(event => {\n    updateValueFromValueStr(event.target.value);\n  });\n  const valueStr = React.useMemo(() => areAllSectionsEmpty ? '' : fieldValueManager.getV7HiddenInputValueFromSections(state.sections), [areAllSectionsEmpty, state.sections, fieldValueManager]);\n  React.useEffect(() => {\n    if (sectionListRef.current == null) {\n      throw new Error(['MUI X: The `sectionListRef` prop has not been initialized by `PickersSectionList`', 'You probably tried to pass a component to the `textField` slot that contains an `<input />` element instead of a `PickersSectionList`.', '', 'If you want to keep using an `<input />` HTML element for the editing, please remove the `enableAccessibleFieldDOMStructure` prop from your picker or field component:', '', '<DatePicker slots={{ textField: MyCustomTextField }} />', '', 'Learn more about the field accessible DOM structure on the MUI documentation: https://mui.com/x/react-date-pickers/fields/#fields-to-edit-a-single-element'].join('\\n'));\n    }\n    if (autoFocus && sectionListRef.current) {\n      sectionListRef.current.getSectionContent(sectionOrder.startIndex).focus();\n    }\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\n\n  return {\n    interactions,\n    returnedValue: {\n      // Forwarded\n      autoFocus,\n      readOnly,\n      focused: focusedProp ?? focused,\n      sectionListRef: handleSectionListRef,\n      onBlur: handleContainerBlur,\n      onClick: handleContainerClick,\n      onFocus: handleContainerFocus,\n      onInput: handleContainerInput,\n      onPaste: handleContainerPaste,\n      // Additional\n      enableAccessibleFieldDOMStructure: true,\n      elements,\n      // TODO v7: Try to set to undefined when there is a section selected.\n      tabIndex: parsedSelectedSections === 0 ? -1 : 0,\n      contentEditable: isContainerEditable,\n      value: valueStr,\n      onChange: handleValueStrChange,\n      areAllSectionsEmpty\n    }\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}