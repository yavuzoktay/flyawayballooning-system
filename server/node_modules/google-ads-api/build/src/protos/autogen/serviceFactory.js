"use strict";
/* Autogenerated File! Do Not Edit */
Object.defineProperty(exports, "__esModule", { value: true });
const service_1 = require("../../service");
const index_1 = require("../index");
class ServiceFactory extends service_1.Service {
    constructor(clientOptions, customerOptions, hooks) {
        super(clientOptions, customerOptions, hooks ?? {});
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AccountBudgetProposalService
     */
    get accountBudgetProposals() {
        const service = this.loadService("AccountBudgetProposalServiceClient");
        return {
            /**
             * @description create resources of type resources.IAccountBudgetProposal
             * @returns services.MutateAccountBudgetProposalResponse
             */
            create: async (accountBudgetProposals, options) => {
                const ops = this.buildOperations("create", accountBudgetProposals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountBudgetProposal(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAccountBudgetProposalResponse
             */
            remove: async (accountBudgetProposals, options) => {
                const ops = this.buildOperations("remove", accountBudgetProposals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountBudgetProposalService.mutateAccountBudgetProposal",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountBudgetProposal(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AccountLinkService
     */
    get accountLinks() {
        const service = this.loadService("AccountLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AccountLinkService#createaccountlink
             */
            createAccountLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.CreateAccountLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAccountLink
             * @returns services.MutateAccountLinkResponse
             */
            update: async (accountLinks, options) => {
                const ops = this.buildOperations("update", accountLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AccountLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.mutateAccountLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAccountLinkResponse
             */
            remove: async (accountLinks, options) => {
                const ops = this.buildOperations("remove", accountLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AccountLinkService.mutateAccountLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAccountLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupAdLabelService
     */
    get adGroupAdLabels() {
        const service = this.loadService("AdGroupAdLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAdLabel
             * @returns services.MutateAdGroupAdLabelsResponse
             */
            create: async (adGroupAdLabels, options) => {
                const ops = this.buildOperations("create", adGroupAdLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAdLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAdLabelsResponse
             */
            remove: async (adGroupAdLabels, options) => {
                const ops = this.buildOperations("remove", adGroupAdLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdLabelService.mutateAdGroupAdLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAdLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupAdService
     */
    get adGroupAds() {
        const service = this.loadService("AdGroupAdServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAd
             * @returns services.MutateAdGroupAdsResponse
             */
            create: async (adGroupAds, options) => {
                const ops = this.buildOperations("create", adGroupAds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupAd
             * @returns services.MutateAdGroupAdsResponse
             */
            update: async (adGroupAds, options) => {
                const ops = this.buildOperations("update", adGroupAds, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupAd);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAdsResponse
             */
            remove: async (adGroupAds, options) => {
                const ops = this.buildOperations("remove", adGroupAds);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.mutateAdGroupAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupAdService#removeautomaticallycreatedassets
             */
            removeAutomaticallyCreatedAssets: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAdService.RemoveAutomaticallyCreatedAssets",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeAutomaticallyCreatedAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupAssetService
     */
    get adGroupAssets() {
        const service = this.loadService("AdGroupAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAsset
             * @returns services.MutateAdGroupAssetsResponse
             */
            create: async (adGroupAssets, options) => {
                const ops = this.buildOperations("create", adGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupAsset
             * @returns services.MutateAdGroupAssetsResponse
             */
            update: async (adGroupAssets, options) => {
                const ops = this.buildOperations("update", adGroupAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAssetsResponse
             */
            remove: async (adGroupAssets, options) => {
                const ops = this.buildOperations("remove", adGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetService.mutateAdGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupAssetSetService
     */
    get adGroupAssetSets() {
        const service = this.loadService("AdGroupAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupAssetSet
             * @returns services.MutateAdGroupAssetSetsResponse
             */
            create: async (adGroupAssetSets, options) => {
                const ops = this.buildOperations("create", adGroupAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupAssetSetsResponse
             */
            remove: async (adGroupAssetSets, options) => {
                const ops = this.buildOperations("remove", adGroupAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupAssetSetService.mutateAdGroupAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupBidModifierService
     */
    get adGroupBidModifiers() {
        const service = this.loadService("AdGroupBidModifierServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupBidModifier
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            create: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("create", adGroupBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupBidModifier
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            update: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("update", adGroupBidModifiers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupBidModifier);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupBidModifiersResponse
             */
            remove: async (adGroupBidModifiers, options) => {
                const ops = this.buildOperations("remove", adGroupBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupBidModifierService.mutateAdGroupBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupCriterionCustomizerService
     */
    get adGroupCriterionCustomizers() {
        const service = this.loadService("AdGroupCriterionCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterionCustomizer
             * @returns services.MutateAdGroupCriterionCustomizersResponse
             */
            create: async (adGroupCriterionCustomizers, options) => {
                const ops = this.buildOperations("create", adGroupCriterionCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriterionCustomizersResponse
             */
            remove: async (adGroupCriterionCustomizers, options) => {
                const ops = this.buildOperations("remove", adGroupCriterionCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionCustomizerService.mutateAdGroupCriterionCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupCriterionLabelService
     */
    get adGroupCriterionLabels() {
        const service = this.loadService("AdGroupCriterionLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterionLabel
             * @returns services.MutateAdGroupCriterionLabelsResponse
             */
            create: async (adGroupCriterionLabels, options) => {
                const ops = this.buildOperations("create", adGroupCriterionLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriterionLabelsResponse
             */
            remove: async (adGroupCriterionLabels, options) => {
                const ops = this.buildOperations("remove", adGroupCriterionLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionLabelService.mutateAdGroupCriterionLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriterionLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupCriterionService
     */
    get adGroupCriteria() {
        const service = this.loadService("AdGroupCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCriterion
             * @returns services.MutateAdGroupCriteriaResponse
             */
            create: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("create", adGroupCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroupCriterion
             * @returns services.MutateAdGroupCriteriaResponse
             */
            update: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("update", adGroupCriteria, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroupCriterion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCriteriaResponse
             */
            remove: async (adGroupCriteria, options) => {
                const ops = this.buildOperations("remove", adGroupCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCriterionService.mutateAdGroupCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupCustomizerService
     */
    get adGroupCustomizers() {
        const service = this.loadService("AdGroupCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupCustomizer
             * @returns services.MutateAdGroupCustomizersResponse
             */
            create: async (adGroupCustomizers, options) => {
                const ops = this.buildOperations("create", adGroupCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupCustomizersResponse
             */
            remove: async (adGroupCustomizers, options) => {
                const ops = this.buildOperations("remove", adGroupCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupCustomizerService.mutateAdGroupCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupLabelService
     */
    get adGroupLabels() {
        const service = this.loadService("AdGroupLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroupLabel
             * @returns services.MutateAdGroupLabelsResponse
             */
            create: async (adGroupLabels, options) => {
                const ops = this.buildOperations("create", adGroupLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupLabelService.mutateAdGroupLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupLabelsResponse
             */
            remove: async (adGroupLabels, options) => {
                const ops = this.buildOperations("remove", adGroupLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupLabelService.mutateAdGroupLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroupLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdGroupService
     */
    get adGroups() {
        const service = this.loadService("AdGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdGroup
             * @returns services.MutateAdGroupsResponse
             */
            create: async (adGroups, options) => {
                const ops = this.buildOperations("create", adGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdGroup
             * @returns services.MutateAdGroupsResponse
             */
            update: async (adGroups, options) => {
                const ops = this.buildOperations("update", adGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdGroupsResponse
             */
            remove: async (adGroups, options) => {
                const ops = this.buildOperations("remove", adGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdGroupService.mutateAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdParameterService
     */
    get adParameters() {
        const service = this.loadService("AdParameterServiceClient");
        return {
            /**
             * @description create resources of type resources.IAdParameter
             * @returns services.MutateAdParametersResponse
             */
            create: async (adParameters, options) => {
                const ops = this.buildOperations("create", adParameters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAdParameter
             * @returns services.MutateAdParametersResponse
             */
            update: async (adParameters, options) => {
                const ops = this.buildOperations("update", adParameters, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AdParameter);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAdParametersResponse
             */
            remove: async (adParameters, options) => {
                const ops = this.buildOperations("remove", adParameters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdParameterService.mutateAdParameters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAdParameters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AdService
     */
    get ads() {
        const service = this.loadService("AdServiceClient");
        return {
            /**
             * @description update resources of type resources.IAd
             * @returns services.MutateAdsResponse
             */
            update: async (ads, options) => {
                const ops = this.buildOperations("update", ads, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Ad);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AdService.mutateAds",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAds(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetGroupAssetService
     */
    get assetGroupAssets() {
        const service = this.loadService("AssetGroupAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupAsset
             * @returns services.MutateAssetGroupAssetsResponse
             */
            create: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("create", assetGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroupAsset
             * @returns services.MutateAssetGroupAssetsResponse
             */
            update: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("update", assetGroupAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroupAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupAssetsResponse
             */
            remove: async (assetGroupAssets, options) => {
                const ops = this.buildOperations("remove", assetGroupAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupAssetService.mutateAssetGroupAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetGroupListingGroupFilterService
     */
    get assetGroupListingGroupFilters() {
        const service = this.loadService("AssetGroupListingGroupFilterServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupListingGroupFilter
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            create: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("create", assetGroupListingGroupFilters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroupListingGroupFilter
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            update: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("update", assetGroupListingGroupFilters, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroupListingGroupFilter);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupListingGroupFiltersResponse
             */
            remove: async (assetGroupListingGroupFilters, options) => {
                const ops = this.buildOperations("remove", assetGroupListingGroupFilters);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupListingGroupFilterService.mutateAssetGroupListingGroupFilters",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupListingGroupFilters(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetGroupService
     */
    get assetGroups() {
        const service = this.loadService("AssetGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroup
             * @returns services.MutateAssetGroupsResponse
             */
            create: async (assetGroups, options) => {
                const ops = this.buildOperations("create", assetGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetGroup
             * @returns services.MutateAssetGroupsResponse
             */
            update: async (assetGroups, options) => {
                const ops = this.buildOperations("update", assetGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupsResponse
             */
            remove: async (assetGroups, options) => {
                const ops = this.buildOperations("remove", assetGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupService.mutateAssetGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetGroupSignalService
     */
    get assetGroupSignals() {
        const service = this.loadService("AssetGroupSignalServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetGroupSignal
             * @returns services.MutateAssetGroupSignalsResponse
             */
            create: async (assetGroupSignals, options) => {
                const ops = this.buildOperations("create", assetGroupSignals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupSignalService.mutateAssetGroupSignals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupSignals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetGroupSignalsResponse
             */
            remove: async (assetGroupSignals, options) => {
                const ops = this.buildOperations("remove", assetGroupSignals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetGroupSignalService.mutateAssetGroupSignals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetGroupSignals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetService
     */
    get assets() {
        const service = this.loadService("AssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAsset
             * @returns services.MutateAssetsResponse
             */
            create: async (assets, options) => {
                const ops = this.buildOperations("create", assets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetService.mutateAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAsset
             * @returns services.MutateAssetsResponse
             */
            update: async (assets, options) => {
                const ops = this.buildOperations("update", assets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Asset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetService.mutateAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetSetAssetService
     */
    get assetSetAssets() {
        const service = this.loadService("AssetSetAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetSetAsset
             * @returns services.MutateAssetSetAssetsResponse
             */
            create: async (assetSetAssets, options) => {
                const ops = this.buildOperations("create", assetSetAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetAssetService.mutateAssetSetAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSetAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetSetAssetsResponse
             */
            remove: async (assetSetAssets, options) => {
                const ops = this.buildOperations("remove", assetSetAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetAssetService.mutateAssetSetAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSetAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AssetSetService
     */
    get assetSets() {
        const service = this.loadService("AssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IAssetSet
             * @returns services.MutateAssetSetsResponse
             */
            create: async (assetSets, options) => {
                const ops = this.buildOperations("create", assetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAssetSet
             * @returns services.MutateAssetSetsResponse
             */
            update: async (assetSets, options) => {
                const ops = this.buildOperations("update", assetSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.AssetSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateAssetSetsResponse
             */
            remove: async (assetSets, options) => {
                const ops = this.buildOperations("remove", assetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AssetSetService.mutateAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService
     */
    get audienceInsights() {
        const service = this.loadService("AudienceInsightsServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#generateinsightsfinderreport
             */
            generateInsightsFinderReport: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateInsightsFinderReport",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateInsightsFinderReport(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#listaudienceinsightsattributes
             */
            listAudienceInsightsAttributes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.ListAudienceInsightsAttributes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listAudienceInsightsAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#listinsightseligibledates
             */
            listInsightsEligibleDates: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.ListInsightsEligibleDates",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listInsightsEligibleDates(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#generateaudiencecompositioninsights
             */
            generateAudienceCompositionInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateAudienceCompositionInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateAudienceCompositionInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#generatesuggestedtargetinginsights
             */
            generateSuggestedTargetingInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateSuggestedTargetingInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateSuggestedTargetingInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#generateaudienceoverlapinsights
             */
            generateAudienceOverlapInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateAudienceOverlapInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateAudienceOverlapInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceInsightsService#generatetargetingsuggestionmetrics
             */
            generateTargetingSuggestionMetrics: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceInsightsService.GenerateTargetingSuggestionMetrics",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateTargetingSuggestionMetrics(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AudienceService
     */
    get audiences() {
        const service = this.loadService("AudienceServiceClient");
        return {
            /**
             * @description create resources of type resources.IAudience
             * @returns services.MutateAudiencesResponse
             */
            create: async (audiences, options) => {
                const ops = this.buildOperations("create", audiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceService.mutateAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IAudience
             * @returns services.MutateAudiencesResponse
             */
            update: async (audiences, options) => {
                const ops = this.buildOperations("update", audiences, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Audience);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AudienceService.mutateAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AutomaticallyCreatedAssetRemovalService
     */
    get automaticallyCreatedAssetRemovals() {
        const service = this.loadService("AutomaticallyCreatedAssetRemovalServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/AutomaticallyCreatedAssetRemovalService#removecampaignautomaticallycreatedasset
             */
            removeCampaignAutomaticallyCreatedAsset: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "AutomaticallyCreatedAssetRemovalService.RemoveCampaignAutomaticallyCreatedAsset",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeCampaignAutomaticallyCreatedAsset(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BatchJobService
     */
    get batchJobs() {
        const service = this.loadService("BatchJobServiceClient");
        return {
            /**
             * @description create resources of type resources.IBatchJob
             * @returns services.MutateBatchJobResponse
             */
            create: async (batchJobs, options) => {
                const ops = this.buildOperations("create", batchJobs);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.mutateBatchJob",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBatchJobResponse
             */
            remove: async (batchJobs, options) => {
                const ops = this.buildOperations("remove", batchJobs);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.mutateBatchJob",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BatchJobService#listbatchjobresults
             */
            listBatchJobResults: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.ListBatchJobResults",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listBatchJobResults(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BatchJobService#runbatchjob
             */
            runBatchJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.RunBatchJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.runBatchJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BatchJobService#addbatchjoboperations
             */
            addBatchJobOperations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BatchJobService.AddBatchJobOperations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.addBatchJobOperations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BiddingDataExclusionService
     */
    get biddingDataExclusions() {
        const service = this.loadService("BiddingDataExclusionServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingDataExclusion
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            create: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("create", biddingDataExclusions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingDataExclusion
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            update: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("update", biddingDataExclusions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingDataExclusion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingDataExclusionsResponse
             */
            remove: async (biddingDataExclusions, options) => {
                const ops = this.buildOperations("remove", biddingDataExclusions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingDataExclusionService.mutateBiddingDataExclusions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingDataExclusions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BiddingSeasonalityAdjustmentService
     */
    get biddingSeasonalityAdjustments() {
        const service = this.loadService("BiddingSeasonalityAdjustmentServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingSeasonalityAdjustment
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            create: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("create", biddingSeasonalityAdjustments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingSeasonalityAdjustment
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            update: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("update", biddingSeasonalityAdjustments, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingSeasonalityAdjustment);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingSeasonalityAdjustmentsResponse
             */
            remove: async (biddingSeasonalityAdjustments, options) => {
                const ops = this.buildOperations("remove", biddingSeasonalityAdjustments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingSeasonalityAdjustmentService.mutateBiddingSeasonalityAdjustments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingSeasonalityAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BiddingStrategyService
     */
    get biddingStrategies() {
        const service = this.loadService("BiddingStrategyServiceClient");
        return {
            /**
             * @description create resources of type resources.IBiddingStrategy
             * @returns services.MutateBiddingStrategiesResponse
             */
            create: async (biddingStrategies, options) => {
                const ops = this.buildOperations("create", biddingStrategies);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IBiddingStrategy
             * @returns services.MutateBiddingStrategiesResponse
             */
            update: async (biddingStrategies, options) => {
                const ops = this.buildOperations("update", biddingStrategies, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.BiddingStrategy);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBiddingStrategiesResponse
             */
            remove: async (biddingStrategies, options) => {
                const ops = this.buildOperations("remove", biddingStrategies);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BiddingStrategyService.mutateBiddingStrategies",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBiddingStrategies(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignAssetService
     */
    get campaignAssets() {
        const service = this.loadService("CampaignAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignAsset
             * @returns services.MutateCampaignAssetsResponse
             */
            create: async (campaignAssets, options) => {
                const ops = this.buildOperations("create", campaignAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignAsset
             * @returns services.MutateCampaignAssetsResponse
             */
            update: async (campaignAssets, options) => {
                const ops = this.buildOperations("update", campaignAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignAssetsResponse
             */
            remove: async (campaignAssets, options) => {
                const ops = this.buildOperations("remove", campaignAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetService.mutateCampaignAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignAssetSetService
     */
    get campaignAssetSets() {
        const service = this.loadService("CampaignAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignAssetSet
             * @returns services.MutateCampaignAssetSetsResponse
             */
            create: async (campaignAssetSets, options) => {
                const ops = this.buildOperations("create", campaignAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetSetService.mutateCampaignAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignAssetSetsResponse
             */
            remove: async (campaignAssetSets, options) => {
                const ops = this.buildOperations("remove", campaignAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignAssetSetService.mutateCampaignAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignBidModifierService
     */
    get campaignBidModifiers() {
        const service = this.loadService("CampaignBidModifierServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignBidModifier
             * @returns services.MutateCampaignBidModifiersResponse
             */
            create: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("create", campaignBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignBidModifier
             * @returns services.MutateCampaignBidModifiersResponse
             */
            update: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("update", campaignBidModifiers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignBidModifier);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignBidModifiersResponse
             */
            remove: async (campaignBidModifiers, options) => {
                const ops = this.buildOperations("remove", campaignBidModifiers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBidModifierService.mutateCampaignBidModifiers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBidModifiers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignBudgetService
     */
    get campaignBudgets() {
        const service = this.loadService("CampaignBudgetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignBudget
             * @returns services.MutateCampaignBudgetsResponse
             */
            create: async (campaignBudgets, options) => {
                const ops = this.buildOperations("create", campaignBudgets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignBudget
             * @returns services.MutateCampaignBudgetsResponse
             */
            update: async (campaignBudgets, options) => {
                const ops = this.buildOperations("update", campaignBudgets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignBudget);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignBudgetsResponse
             */
            remove: async (campaignBudgets, options) => {
                const ops = this.buildOperations("remove", campaignBudgets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignBudgetService.mutateCampaignBudgets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignBudgets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignConversionGoalService
     */
    get campaignConversionGoals() {
        const service = this.loadService("CampaignConversionGoalServiceClient");
        return {
            /**
             * @description update resources of type resources.ICampaignConversionGoal
             * @returns services.MutateCampaignConversionGoalsResponse
             */
            update: async (campaignConversionGoals, options) => {
                const ops = this.buildOperations("update", campaignConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignConversionGoalService.mutateCampaignConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignCriterionService
     */
    get campaignCriteria() {
        const service = this.loadService("CampaignCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignCriterion
             * @returns services.MutateCampaignCriteriaResponse
             */
            create: async (campaignCriteria, options) => {
                const ops = this.buildOperations("create", campaignCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignCriterion
             * @returns services.MutateCampaignCriteriaResponse
             */
            update: async (campaignCriteria, options) => {
                const ops = this.buildOperations("update", campaignCriteria, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignCriterion);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignCriteriaResponse
             */
            remove: async (campaignCriteria, options) => {
                const ops = this.buildOperations("remove", campaignCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCriterionService.mutateCampaignCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignCustomizerService
     */
    get campaignCustomizers() {
        const service = this.loadService("CampaignCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignCustomizer
             * @returns services.MutateCampaignCustomizersResponse
             */
            create: async (campaignCustomizers, options) => {
                const ops = this.buildOperations("create", campaignCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCustomizerService.mutateCampaignCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignCustomizersResponse
             */
            remove: async (campaignCustomizers, options) => {
                const ops = this.buildOperations("remove", campaignCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignCustomizerService.mutateCampaignCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignDraftService
     */
    get campaignDrafts() {
        const service = this.loadService("CampaignDraftServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignDraft
             * @returns services.MutateCampaignDraftsResponse
             */
            create: async (campaignDrafts, options) => {
                const ops = this.buildOperations("create", campaignDrafts);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignDraft
             * @returns services.MutateCampaignDraftsResponse
             */
            update: async (campaignDrafts, options) => {
                const ops = this.buildOperations("update", campaignDrafts, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignDraft);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignDraftsResponse
             */
            remove: async (campaignDrafts, options) => {
                const ops = this.buildOperations("remove", campaignDrafts);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.mutateCampaignDrafts",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignDrafts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignDraftService#promotecampaigndraft
             */
            promoteCampaignDraft: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.PromoteCampaignDraft",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.promoteCampaignDraft(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignDraftService#listcampaigndraftasyncerrors
             */
            listCampaignDraftAsyncErrors: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignDraftService.ListCampaignDraftAsyncErrors",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listCampaignDraftAsyncErrors(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignGroupService
     */
    get campaignGroups() {
        const service = this.loadService("CampaignGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignGroup
             * @returns services.MutateCampaignGroupsResponse
             */
            create: async (campaignGroups, options) => {
                const ops = this.buildOperations("create", campaignGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaignGroup
             * @returns services.MutateCampaignGroupsResponse
             */
            update: async (campaignGroups, options) => {
                const ops = this.buildOperations("update", campaignGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CampaignGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignGroupsResponse
             */
            remove: async (campaignGroups, options) => {
                const ops = this.buildOperations("remove", campaignGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignGroupService.mutateCampaignGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignLabelService
     */
    get campaignLabels() {
        const service = this.loadService("CampaignLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignLabel
             * @returns services.MutateCampaignLabelsResponse
             */
            create: async (campaignLabels, options) => {
                const ops = this.buildOperations("create", campaignLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignLabelService.mutateCampaignLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignLabelsResponse
             */
            remove: async (campaignLabels, options) => {
                const ops = this.buildOperations("remove", campaignLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignLabelService.mutateCampaignLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignService
     */
    get campaigns() {
        const service = this.loadService("CampaignServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaign
             * @returns services.MutateCampaignsResponse
             */
            create: async (campaigns, options) => {
                const ops = this.buildOperations("create", campaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICampaign
             * @returns services.MutateCampaignsResponse
             */
            update: async (campaigns, options) => {
                const ops = this.buildOperations("update", campaigns, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Campaign);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignsResponse
             */
            remove: async (campaigns, options) => {
                const ops = this.buildOperations("remove", campaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.mutateCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignService#enablepmaxbrandguidelines
             */
            enablePMaxBrandGuidelines: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignService.EnablePMaxBrandGuidelines",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.enablePMaxBrandGuidelines(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignSharedSetService
     */
    get campaignSharedSets() {
        const service = this.loadService("CampaignSharedSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICampaignSharedSet
             * @returns services.MutateCampaignSharedSetsResponse
             */
            create: async (campaignSharedSets, options) => {
                const ops = this.buildOperations("create", campaignSharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignSharedSetService.mutateCampaignSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCampaignSharedSetsResponse
             */
            remove: async (campaignSharedSets, options) => {
                const ops = this.buildOperations("remove", campaignSharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignSharedSetService.mutateCampaignSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCampaignSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionActionService
     */
    get conversionActions() {
        const service = this.loadService("ConversionActionServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionAction
             * @returns services.MutateConversionActionsResponse
             */
            create: async (conversionActions, options) => {
                const ops = this.buildOperations("create", conversionActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionAction
             * @returns services.MutateConversionActionsResponse
             */
            update: async (conversionActions, options) => {
                const ops = this.buildOperations("update", conversionActions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionAction);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionActionsResponse
             */
            remove: async (conversionActions, options) => {
                const ops = this.buildOperations("remove", conversionActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionActionService.mutateConversionActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionCustomVariableService
     */
    get conversionCustomVariables() {
        const service = this.loadService("ConversionCustomVariableServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionCustomVariable
             * @returns services.MutateConversionCustomVariablesResponse
             */
            create: async (conversionCustomVariables, options) => {
                const ops = this.buildOperations("create", conversionCustomVariables);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionCustomVariableService.mutateConversionCustomVariables",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionCustomVariables(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionCustomVariable
             * @returns services.MutateConversionCustomVariablesResponse
             */
            update: async (conversionCustomVariables, options) => {
                const ops = this.buildOperations("update", conversionCustomVariables, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionCustomVariable);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionCustomVariableService.mutateConversionCustomVariables",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionCustomVariables(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionGoalCampaignConfigService
     */
    get conversionGoalCampaignConfigs() {
        const service = this.loadService("ConversionGoalCampaignConfigServiceClient");
        return {
            /**
             * @description update resources of type resources.IConversionGoalCampaignConfig
             * @returns services.MutateConversionGoalCampaignConfigsResponse
             */
            update: async (conversionGoalCampaignConfigs, options) => {
                const ops = this.buildOperations("update", conversionGoalCampaignConfigs, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionGoalCampaignConfig);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionGoalCampaignConfigService.mutateConversionGoalCampaignConfigs",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionGoalCampaignConfigs(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionValueRuleService
     */
    get conversionValueRules() {
        const service = this.loadService("ConversionValueRuleServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionValueRule
             * @returns services.MutateConversionValueRulesResponse
             */
            create: async (conversionValueRules, options) => {
                const ops = this.buildOperations("create", conversionValueRules);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionValueRule
             * @returns services.MutateConversionValueRulesResponse
             */
            update: async (conversionValueRules, options) => {
                const ops = this.buildOperations("update", conversionValueRules, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionValueRule);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionValueRulesResponse
             */
            remove: async (conversionValueRules, options) => {
                const ops = this.buildOperations("remove", conversionValueRules);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleService.mutateConversionValueRules",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRules(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionValueRuleSetService
     */
    get conversionValueRuleSets() {
        const service = this.loadService("ConversionValueRuleSetServiceClient");
        return {
            /**
             * @description create resources of type resources.IConversionValueRuleSet
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            create: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("create", conversionValueRuleSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IConversionValueRuleSet
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            update: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("update", conversionValueRuleSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ConversionValueRuleSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateConversionValueRuleSetsResponse
             */
            remove: async (conversionValueRuleSets, options) => {
                const ops = this.buildOperations("remove", conversionValueRuleSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionValueRuleSetService.mutateConversionValueRuleSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateConversionValueRuleSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomConversionGoalService
     */
    get customConversionGoals() {
        const service = this.loadService("CustomConversionGoalServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomConversionGoal
             * @returns services.MutateCustomConversionGoalsResponse
             */
            create: async (customConversionGoals, options) => {
                const ops = this.buildOperations("create", customConversionGoals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomConversionGoal
             * @returns services.MutateCustomConversionGoalsResponse
             */
            update: async (customConversionGoals, options) => {
                const ops = this.buildOperations("update", customConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomConversionGoalsResponse
             */
            remove: async (customConversionGoals, options) => {
                const ops = this.buildOperations("remove", customConversionGoals);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomConversionGoalService.mutateCustomConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerAssetService
     */
    get customerAssets() {
        const service = this.loadService("CustomerAssetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerAsset
             * @returns services.MutateCustomerAssetsResponse
             */
            create: async (customerAssets, options) => {
                const ops = this.buildOperations("create", customerAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerAsset
             * @returns services.MutateCustomerAssetsResponse
             */
            update: async (customerAssets, options) => {
                const ops = this.buildOperations("update", customerAssets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerAsset);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerAssetsResponse
             */
            remove: async (customerAssets, options) => {
                const ops = this.buildOperations("remove", customerAssets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetService.mutateCustomerAssets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerConversionGoalService
     */
    get customerConversionGoals() {
        const service = this.loadService("CustomerConversionGoalServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerConversionGoal
             * @returns services.MutateCustomerConversionGoalsResponse
             */
            update: async (customerConversionGoals, options) => {
                const ops = this.buildOperations("update", customerConversionGoals, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerConversionGoal);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerConversionGoalService.mutateCustomerConversionGoals",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerConversionGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerCustomizerService
     */
    get customerCustomizers() {
        const service = this.loadService("CustomerCustomizerServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerCustomizer
             * @returns services.MutateCustomerCustomizersResponse
             */
            create: async (customerCustomizers, options) => {
                const ops = this.buildOperations("create", customerCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerCustomizerService.mutateCustomerCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerCustomizersResponse
             */
            remove: async (customerCustomizers, options) => {
                const ops = this.buildOperations("remove", customerCustomizers);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerCustomizerService.mutateCustomerCustomizers",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerCustomizers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerLabelService
     */
    get customerLabels() {
        const service = this.loadService("CustomerLabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerLabel
             * @returns services.MutateCustomerLabelsResponse
             */
            create: async (customerLabels, options) => {
                const ops = this.buildOperations("create", customerLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerLabelService.mutateCustomerLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerLabelsResponse
             */
            remove: async (customerLabels, options) => {
                const ops = this.buildOperations("remove", customerLabels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerLabelService.mutateCustomerLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerNegativeCriterionService
     */
    get customerNegativeCriteria() {
        const service = this.loadService("CustomerNegativeCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerNegativeCriterion
             * @returns services.MutateCustomerNegativeCriteriaResponse
             */
            create: async (customerNegativeCriteria, options) => {
                const ops = this.buildOperations("create", customerNegativeCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerNegativeCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerNegativeCriteriaResponse
             */
            remove: async (customerNegativeCriteria, options) => {
                const ops = this.buildOperations("remove", customerNegativeCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerNegativeCriterionService.mutateCustomerNegativeCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerNegativeCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerService
     */
    get customers() {
        const service = this.loadService("CustomerServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomer
             * @returns services.MutateCustomerResponse
             */
            update: async (customers, options) => {
                const ops = this.buildOperations("update", customers, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Customer);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.mutateCustomer",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomer(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerService#listaccessiblecustomers
             */
            listAccessibleCustomers: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.ListAccessibleCustomers",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listAccessibleCustomers(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerService#createcustomerclient
             */
            createCustomerClient: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerService.CreateCustomerClient",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createCustomerClient(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomizerAttributeService
     */
    get customizerAttributes() {
        const service = this.loadService("CustomizerAttributeServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomizerAttribute
             * @returns services.MutateCustomizerAttributesResponse
             */
            create: async (customizerAttributes, options) => {
                const ops = this.buildOperations("create", customizerAttributes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomizerAttributeService.mutateCustomizerAttributes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomizerAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomizerAttributesResponse
             */
            remove: async (customizerAttributes, options) => {
                const ops = this.buildOperations("remove", customizerAttributes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomizerAttributeService.mutateCustomizerAttributes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomizerAttributes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentArmService
     */
    get experimentArms() {
        const service = this.loadService("ExperimentArmServiceClient");
        return {
            /**
             * @description create resources of type resources.IExperimentArm
             * @returns services.MutateExperimentArmsResponse
             */
            create: async (experimentArms, options) => {
                const ops = this.buildOperations("create", experimentArms);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IExperimentArm
             * @returns services.MutateExperimentArmsResponse
             */
            update: async (experimentArms, options) => {
                const ops = this.buildOperations("update", experimentArms, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.ExperimentArm);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateExperimentArmsResponse
             */
            remove: async (experimentArms, options) => {
                const ops = this.buildOperations("remove", experimentArms);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentArmService.mutateExperimentArms",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperimentArms(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService
     */
    get experiments() {
        const service = this.loadService("ExperimentServiceClient");
        return {
            /**
             * @description create resources of type resources.IExperiment
             * @returns services.MutateExperimentsResponse
             */
            create: async (experiments, options) => {
                const ops = this.buildOperations("create", experiments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IExperiment
             * @returns services.MutateExperimentsResponse
             */
            update: async (experiments, options) => {
                const ops = this.buildOperations("update", experiments, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Experiment);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateExperimentsResponse
             */
            remove: async (experiments, options) => {
                const ops = this.buildOperations("remove", experiments);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.mutateExperiments",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateExperiments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService#endexperiment
             */
            endExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.EndExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.endExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService#listexperimentasyncerrors
             */
            listExperimentAsyncErrors: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.ListExperimentAsyncErrors",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listExperimentAsyncErrors(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService#graduateexperiment
             */
            graduateExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.GraduateExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.graduateExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService#scheduleexperiment
             */
            scheduleExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.ScheduleExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.scheduleExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ExperimentService#promoteexperiment
             */
            promoteExperiment: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ExperimentService.PromoteExperiment",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.promoteExperiment(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanAdGroupKeywordService
     */
    get keywordPlanAdGroupKeywords() {
        const service = this.loadService("KeywordPlanAdGroupKeywordServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanAdGroupKeyword
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            create: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("create", keywordPlanAdGroupKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanAdGroupKeyword
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            update: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("update", keywordPlanAdGroupKeywords, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanAdGroupKeyword);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanAdGroupKeywordsResponse
             */
            remove: async (keywordPlanAdGroupKeywords, options) => {
                const ops = this.buildOperations("remove", keywordPlanAdGroupKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupKeywordService.mutateKeywordPlanAdGroupKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroupKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanAdGroupService
     */
    get keywordPlanAdGroups() {
        const service = this.loadService("KeywordPlanAdGroupServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanAdGroup
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            create: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("create", keywordPlanAdGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanAdGroup
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            update: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("update", keywordPlanAdGroups, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanAdGroup);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanAdGroupsResponse
             */
            remove: async (keywordPlanAdGroups, options) => {
                const ops = this.buildOperations("remove", keywordPlanAdGroups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanAdGroupService.mutateKeywordPlanAdGroups",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanAdGroups(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanCampaignKeywordService
     */
    get keywordPlanCampaignKeywords() {
        const service = this.loadService("KeywordPlanCampaignKeywordServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanCampaignKeyword
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            create: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("create", keywordPlanCampaignKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanCampaignKeyword
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            update: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("update", keywordPlanCampaignKeywords, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanCampaignKeyword);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanCampaignKeywordsResponse
             */
            remove: async (keywordPlanCampaignKeywords, options) => {
                const ops = this.buildOperations("remove", keywordPlanCampaignKeywords);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignKeywordService.mutateKeywordPlanCampaignKeywords",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaignKeywords(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanCampaignService
     */
    get keywordPlanCampaigns() {
        const service = this.loadService("KeywordPlanCampaignServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlanCampaign
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            create: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("create", keywordPlanCampaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlanCampaign
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            update: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("update", keywordPlanCampaigns, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlanCampaign);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlanCampaignsResponse
             */
            remove: async (keywordPlanCampaigns, options) => {
                const ops = this.buildOperations("remove", keywordPlanCampaigns);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanCampaignService.mutateKeywordPlanCampaigns",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlanCampaigns(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanService
     */
    get keywordPlans() {
        const service = this.loadService("KeywordPlanServiceClient");
        return {
            /**
             * @description create resources of type resources.IKeywordPlan
             * @returns services.MutateKeywordPlansResponse
             */
            create: async (keywordPlans, options) => {
                const ops = this.buildOperations("create", keywordPlans);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IKeywordPlan
             * @returns services.MutateKeywordPlansResponse
             */
            update: async (keywordPlans, options) => {
                const ops = this.buildOperations("update", keywordPlans, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.KeywordPlan);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateKeywordPlansResponse
             */
            remove: async (keywordPlans, options) => {
                const ops = this.buildOperations("remove", keywordPlans);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanService.mutateKeywordPlans",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateKeywordPlans(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/LabelService
     */
    get labels() {
        const service = this.loadService("LabelServiceClient");
        return {
            /**
             * @description create resources of type resources.ILabel
             * @returns services.MutateLabelsResponse
             */
            create: async (labels, options) => {
                const ops = this.buildOperations("create", labels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ILabel
             * @returns services.MutateLabelsResponse
             */
            update: async (labels, options) => {
                const ops = this.buildOperations("update", labels, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.Label);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateLabelsResponse
             */
            remove: async (labels, options) => {
                const ops = this.buildOperations("remove", labels);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LabelService.mutateLabels",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateLabels(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RecommendationSubscriptionService
     */
    get recommendationSubscriptions() {
        const service = this.loadService("RecommendationSubscriptionServiceClient");
        return {
            /**
             * @description create resources of type resources.IRecommendationSubscription
             * @returns services.MutateRecommendationSubscriptionResponse
             */
            create: async (recommendationSubscriptions, options) => {
                const ops = this.buildOperations("create", recommendationSubscriptions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationSubscriptionService.mutateRecommendationSubscription",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRecommendationSubscription(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IRecommendationSubscription
             * @returns services.MutateRecommendationSubscriptionResponse
             */
            update: async (recommendationSubscriptions, options) => {
                const ops = this.buildOperations("update", recommendationSubscriptions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.RecommendationSubscription);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationSubscriptionService.mutateRecommendationSubscription",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRecommendationSubscription(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RemarketingActionService
     */
    get remarketingActions() {
        const service = this.loadService("RemarketingActionServiceClient");
        return {
            /**
             * @description create resources of type resources.IRemarketingAction
             * @returns services.MutateRemarketingActionsResponse
             */
            create: async (remarketingActions, options) => {
                const ops = this.buildOperations("create", remarketingActions);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RemarketingActionService.mutateRemarketingActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRemarketingActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IRemarketingAction
             * @returns services.MutateRemarketingActionsResponse
             */
            update: async (remarketingActions, options) => {
                const ops = this.buildOperations("update", remarketingActions, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.RemarketingAction);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RemarketingActionService.mutateRemarketingActions",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateRemarketingActions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SharedCriterionService
     */
    get sharedCriteria() {
        const service = this.loadService("SharedCriterionServiceClient");
        return {
            /**
             * @description create resources of type resources.ISharedCriterion
             * @returns services.MutateSharedCriteriaResponse
             */
            create: async (sharedCriteria, options) => {
                const ops = this.buildOperations("create", sharedCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedCriterionService.mutateSharedCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateSharedCriteriaResponse
             */
            remove: async (sharedCriteria, options) => {
                const ops = this.buildOperations("remove", sharedCriteria);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedCriterionService.mutateSharedCriteria",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedCriteria(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SharedSetService
     */
    get sharedSets() {
        const service = this.loadService("SharedSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ISharedSet
             * @returns services.MutateSharedSetsResponse
             */
            create: async (sharedSets, options) => {
                const ops = this.buildOperations("create", sharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ISharedSet
             * @returns services.MutateSharedSetsResponse
             */
            update: async (sharedSets, options) => {
                const ops = this.buildOperations("update", sharedSets, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.SharedSet);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateSharedSetsResponse
             */
            remove: async (sharedSets, options) => {
                const ops = this.buildOperations("remove", sharedSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SharedSetService.mutateSharedSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSharedSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSettingService
     */
    get smartCampaignSettings() {
        const service = this.loadService("SmartCampaignSettingServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSettingService#getsmartcampaignstatus
             */
            getSmartCampaignStatus: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSettingService.GetSmartCampaignStatus",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.getSmartCampaignStatus(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ISmartCampaignSetting
             * @returns services.MutateSmartCampaignSettingsResponse
             */
            update: async (smartCampaignSettings, options) => {
                const ops = this.buildOperations("update", smartCampaignSettings, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.SmartCampaignSetting);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSettingService.mutateSmartCampaignSettings",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateSmartCampaignSettings(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/UserListService
     */
    get userLists() {
        const service = this.loadService("UserListServiceClient");
        return {
            /**
             * @description create resources of type resources.IUserList
             * @returns services.MutateUserListsResponse
             */
            create: async (userLists, options) => {
                const ops = this.buildOperations("create", userLists);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.IUserList
             * @returns services.MutateUserListsResponse
             */
            update: async (userLists, options) => {
                const ops = this.buildOperations("update", userLists, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.UserList);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateUserListsResponse
             */
            remove: async (userLists, options) => {
                const ops = this.buildOperations("remove", userLists);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListService.mutateUserLists",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BillingSetupService
     */
    get billingSetups() {
        const service = this.loadService("BillingSetupServiceClient");
        return {
            /**
             * @description create resources of type resources.IBillingSetup
             * @returns services.MutateBillingSetupResponse
             */
            create: async (billingSetups, options) => {
                const ops = this.buildOperations("create", billingSetups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BillingSetupService.mutateBillingSetup",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBillingSetup(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateBillingSetupResponse
             */
            remove: async (billingSetups, options) => {
                const ops = this.buildOperations("remove", billingSetups);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BillingSetupService.mutateBillingSetup",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateBillingSetup(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BrandSuggestionService
     */
    get brandSuggestions() {
        const service = this.loadService("BrandSuggestionServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/BrandSuggestionService#suggestbrands
             */
            suggestBrands: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "BrandSuggestionService.SuggestBrands",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestBrands(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignLifecycleGoalService
     */
    get campaignLifecycleGoals() {
        const service = this.loadService("CampaignLifecycleGoalServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CampaignLifecycleGoalService#configurecampaignlifecyclegoals
             */
            configureCampaignLifecycleGoals: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CampaignLifecycleGoalService.ConfigureCampaignLifecycleGoals",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.configureCampaignLifecycleGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ContentCreatorInsightsService
     */
    get contentCreatorInsights() {
        const service = this.loadService("ContentCreatorInsightsServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ContentCreatorInsightsService#generatecreatorinsights
             */
            generateCreatorInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ContentCreatorInsightsService.GenerateCreatorInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateCreatorInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ContentCreatorInsightsService#generatetrendinginsights
             */
            generateTrendingInsights: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ContentCreatorInsightsService.GenerateTrendingInsights",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateTrendingInsights(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionAdjustmentUploadService
     */
    get conversionAdjustmentUploads() {
        const service = this.loadService("ConversionAdjustmentUploadServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionAdjustmentUploadService#uploadconversionadjustments
             */
            uploadConversionAdjustments: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionAdjustmentUploadService.UploadConversionAdjustments",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadConversionAdjustments(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionUploadService
     */
    get conversionUploads() {
        const service = this.loadService("ConversionUploadServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionUploadService#uploadclickconversions
             */
            uploadClickConversions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionUploadService.UploadClickConversions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadClickConversions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ConversionUploadService#uploadcallconversions
             */
            uploadCallConversions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ConversionUploadService.UploadCallConversions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadCallConversions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomAudienceService
     */
    get customAudiences() {
        const service = this.loadService("CustomAudienceServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomAudience
             * @returns services.MutateCustomAudiencesResponse
             */
            create: async (customAudiences, options) => {
                const ops = this.buildOperations("create", customAudiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomAudience
             * @returns services.MutateCustomAudiencesResponse
             */
            update: async (customAudiences, options) => {
                const ops = this.buildOperations("update", customAudiences, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomAudience);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomAudiencesResponse
             */
            remove: async (customAudiences, options) => {
                const ops = this.buildOperations("remove", customAudiences);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomAudienceService.mutateCustomAudiences",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomAudiences(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomInterestService
     */
    get customInterests() {
        const service = this.loadService("CustomInterestServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomInterest
             * @returns services.MutateCustomInterestsResponse
             */
            create: async (customInterests, options) => {
                const ops = this.buildOperations("create", customInterests);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomInterestService.mutateCustomInterests",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomInterests(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomInterest
             * @returns services.MutateCustomInterestsResponse
             */
            update: async (customInterests, options) => {
                const ops = this.buildOperations("update", customInterests, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomInterest);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomInterestService.mutateCustomInterests",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomInterests(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerAssetSetService
     */
    get customerAssetSets() {
        const service = this.loadService("CustomerAssetSetServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerAssetSet
             * @returns services.MutateCustomerAssetSetsResponse
             */
            create: async (customerAssetSets, options) => {
                const ops = this.buildOperations("create", customerAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetSetService.mutateCustomerAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerAssetSetsResponse
             */
            remove: async (customerAssetSets, options) => {
                const ops = this.buildOperations("remove", customerAssetSets);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerAssetSetService.mutateCustomerAssetSets",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerAssetSets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerClientLinkService
     */
    get customerClientLinks() {
        const service = this.loadService("CustomerClientLinkServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerClientLink
             * @returns services.MutateCustomerClientLinkResponse
             */
            create: async (customerClientLinks, options) => {
                const ops = this.buildOperations("create", customerClientLinks);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerClientLinkService.mutateCustomerClientLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerClientLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description update resources of type resources.ICustomerClientLink
             * @returns services.MutateCustomerClientLinkResponse
             */
            update: async (customerClientLinks, options) => {
                const ops = this.buildOperations("update", customerClientLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerClientLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerClientLinkService.mutateCustomerClientLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerClientLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerLifecycleGoalService
     */
    get customerLifecycleGoals() {
        const service = this.loadService("CustomerLifecycleGoalServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerLifecycleGoalService#configurecustomerlifecyclegoals
             */
            configureCustomerLifecycleGoals: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerLifecycleGoalService.ConfigureCustomerLifecycleGoals",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.configureCustomerLifecycleGoals(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerManagerLinkService
     */
    get customerManagerLinks() {
        const service = this.loadService("CustomerManagerLinkServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerManagerLink
             * @returns services.MutateCustomerManagerLinkResponse
             */
            update: async (customerManagerLinks, options) => {
                const ops = this.buildOperations("update", customerManagerLinks, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerManagerLink);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerManagerLinkService.mutateCustomerManagerLink",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerManagerLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerManagerLinkService#movemanagerlink
             */
            moveManagerLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerManagerLinkService.MoveManagerLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.moveManagerLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerSkAdNetworkConversionValueSchemaService
     */
    get customerSkAdNetworkConversionValueSchemas() {
        const service = this.loadService("CustomerSkAdNetworkConversionValueSchemaServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerSkAdNetworkConversionValueSchema
             * @returns services.MutateCustomerSkAdNetworkConversionValueSchemaResponse
             */
            update: async (customerSkAdNetworkConversionValueSchemas, options) => {
                const ops = this.buildOperations("update", customerSkAdNetworkConversionValueSchemas, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerSkAdNetworkConversionValueSchema);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerSkAdNetworkConversionValueSchemaService.mutateCustomerSkAdNetworkConversionValueSchema",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerSkAdNetworkConversionValueSchema(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerUserAccessInvitationService
     */
    get customerUserAccessInvitations() {
        const service = this.loadService("CustomerUserAccessInvitationServiceClient");
        return {
            /**
             * @description create resources of type resources.ICustomerUserAccessInvitation
             * @returns services.MutateCustomerUserAccessInvitationResponse
             */
            create: async (customerUserAccessInvitations, options) => {
                const ops = this.buildOperations("create", customerUserAccessInvitations);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccessInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerUserAccessInvitationResponse
             */
            remove: async (customerUserAccessInvitations, options) => {
                const ops = this.buildOperations("remove", customerUserAccessInvitations);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessInvitationService.mutateCustomerUserAccessInvitation",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccessInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/CustomerUserAccessService
     */
    get customerUserAccesses() {
        const service = this.loadService("CustomerUserAccessServiceClient");
        return {
            /**
             * @description update resources of type resources.ICustomerUserAccess
             * @returns services.MutateCustomerUserAccessResponse
             */
            update: async (customerUserAccesses, options) => {
                const ops = this.buildOperations("update", customerUserAccesses, 
                // @ts-expect-error Static class type here is fine
                index_1.resources.CustomerUserAccess);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessService.mutateCustomerUserAccess",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccess(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateCustomerUserAccessResponse
             */
            remove: async (customerUserAccesses, options) => {
                const ops = this.buildOperations("remove", customerUserAccesses);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "CustomerUserAccessService.mutateCustomerUserAccess",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateCustomerUserAccess(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/DataLinkService
     */
    get dataLinks() {
        const service = this.loadService("DataLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/DataLinkService#createdatalink
             */
            createDataLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "DataLinkService.CreateDataLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createDataLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/DataLinkService#removedatalink
             */
            removeDataLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "DataLinkService.RemoveDataLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeDataLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/DataLinkService#updatedatalink
             */
            updateDataLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "DataLinkService.UpdateDataLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.updateDataLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/GeoTargetConstantService
     */
    get geoTargetConstants() {
        const service = this.loadService("GeoTargetConstantServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/GeoTargetConstantService#suggestgeotargetconstants
             */
            suggestGeoTargetConstants: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "GeoTargetConstantService.SuggestGeoTargetConstants",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestGeoTargetConstants(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/IdentityVerificationService
     */
    get identityVerifications() {
        const service = this.loadService("IdentityVerificationServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/IdentityVerificationService#startidentityverification
             */
            startIdentityVerification: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "IdentityVerificationService.StartIdentityVerification",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.startIdentityVerification(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/IdentityVerificationService#getidentityverification
             */
            getIdentityVerification: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "IdentityVerificationService.GetIdentityVerification",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.getIdentityVerification(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/InvoiceService
     */
    get invoices() {
        const service = this.loadService("InvoiceServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/InvoiceService#listinvoices
             */
            listInvoices: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "InvoiceService.ListInvoices",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listInvoices(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanIdeaService
     */
    get keywordPlanIdeas() {
        const service = this.loadService("KeywordPlanIdeaServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanIdeaService#generatekeywordideas
             */
            generateKeywordIdeas: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordIdeas",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordIdeas(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanIdeaService#generatekeywordhistoricalmetrics
             */
            generateKeywordHistoricalMetrics: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordHistoricalMetrics",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordHistoricalMetrics(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanIdeaService#generateadgroupthemes
             */
            generateAdGroupThemes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateAdGroupThemes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateAdGroupThemes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordPlanIdeaService#generatekeywordforecastmetrics
             */
            generateKeywordForecastMetrics: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordPlanIdeaService.GenerateKeywordForecastMetrics",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateKeywordForecastMetrics(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordThemeConstantService
     */
    get keywordThemeConstants() {
        const service = this.loadService("KeywordThemeConstantServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/KeywordThemeConstantService#suggestkeywordthemeconstants
             */
            suggestKeywordThemeConstants: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "KeywordThemeConstantService.SuggestKeywordThemeConstants",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestKeywordThemeConstants(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/LocalServicesLeadService
     */
    get localsLeadServices() {
        const service = this.loadService("LocalServicesLeadServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/LocalServicesLeadService#appendleadconversation
             */
            appendLeadConversation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LocalServicesLeadService.AppendLeadConversation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.appendLeadConversation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/LocalServicesLeadService#provideleadfeedback
             */
            provideLeadFeedback: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "LocalServicesLeadService.ProvideLeadFeedback",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.provideLeadFeedback(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/OfflineUserDataJobService
     */
    get offlineUserDataJobs() {
        const service = this.loadService("OfflineUserDataJobServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/OfflineUserDataJobService#createofflineuserdatajob
             */
            createOfflineUserDataJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.CreateOfflineUserDataJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createOfflineUserDataJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/OfflineUserDataJobService#addofflineuserdatajoboperations
             */
            addOfflineUserDataJobOperations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.AddOfflineUserDataJobOperations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.addOfflineUserDataJobOperations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/OfflineUserDataJobService#runofflineuserdatajob
             */
            runOfflineUserDataJob: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "OfflineUserDataJobService.RunOfflineUserDataJob",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.runOfflineUserDataJob(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/PaymentsAccountService
     */
    get paymentsAccounts() {
        const service = this.loadService("PaymentsAccountServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/PaymentsAccountService#listpaymentsaccounts
             */
            listPaymentsAccounts: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "PaymentsAccountService.ListPaymentsAccounts",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPaymentsAccounts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkInvitationService
     */
    get productLinkInvitations() {
        const service = this.loadService("ProductLinkInvitationServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkInvitationService#createproductlinkinvitation
             */
            createProductLinkInvitation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkInvitationService.CreateProductLinkInvitation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createProductLinkInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkInvitationService#updateproductlinkinvitation
             */
            updateProductLinkInvitation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkInvitationService.UpdateProductLinkInvitation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.updateProductLinkInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkInvitationService#removeproductlinkinvitation
             */
            removeProductLinkInvitation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkInvitationService.RemoveProductLinkInvitation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeProductLinkInvitation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkService
     */
    get productLinks() {
        const service = this.loadService("ProductLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkService#createproductlink
             */
            createProductLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkService.CreateProductLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.createProductLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ProductLinkService#removeproductlink
             */
            removeProductLink: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ProductLinkService.RemoveProductLink",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.removeProductLink(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService
     */
    get reachPlans() {
        const service = this.loadService("ReachPlanServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#generateconversionrates
             */
            generateConversionRates: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.GenerateConversionRates",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateConversionRates(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#listplannablelocations
             */
            listPlannableLocations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableLocations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableLocations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#listplannableproducts
             */
            listPlannableProducts: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableProducts",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableProducts(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#generatereachforecast
             */
            generateReachForecast: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.GenerateReachForecast",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateReachForecast(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#listplannableuserlists
             */
            listPlannableUserLists: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableUserLists",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableUserLists(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ReachPlanService#listplannableuserinterests
             */
            listPlannableUserInterests: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ReachPlanService.ListPlannableUserInterests",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.listPlannableUserInterests(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RecommendationService
     */
    get recommendations() {
        const service = this.loadService("RecommendationServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RecommendationService#applyrecommendation
             */
            applyRecommendation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationService.ApplyRecommendation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.applyRecommendation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RecommendationService#dismissrecommendation
             */
            dismissRecommendation: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationService.DismissRecommendation",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.dismissRecommendation(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/RecommendationService#generaterecommendations
             */
            generateRecommendations: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "RecommendationService.GenerateRecommendations",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateRecommendations(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ShareablePreviewService
     */
    get shareablePreviews() {
        const service = this.loadService("ShareablePreviewServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ShareablePreviewService#generateshareablepreviews
             */
            generateShareablePreviews: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ShareablePreviewService.GenerateShareablePreviews",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.generateShareablePreviews(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSuggestService
     */
    get smartCampaignSuggests() {
        const service = this.loadService("SmartCampaignSuggestServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSuggestService#suggestsmartcampaignbudgetoptions
             */
            suggestSmartCampaignBudgetOptions: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestSmartCampaignBudgetOptions",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestSmartCampaignBudgetOptions(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSuggestService#suggestsmartcampaignad
             */
            suggestSmartCampaignAd: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestSmartCampaignAd",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestSmartCampaignAd(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/SmartCampaignSuggestService#suggestkeywordthemes
             */
            suggestKeywordThemes: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "SmartCampaignSuggestService.SuggestKeywordThemes",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestKeywordThemes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ThirdPartyAppAnalyticsLinkService
     */
    get thirdPartyAppAnalyticsLinks() {
        const service = this.loadService("ThirdPartyAppAnalyticsLinkServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/ThirdPartyAppAnalyticsLinkService#regenerateshareablelinkid
             */
            regenerateShareableLinkId: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "ThirdPartyAppAnalyticsLinkService.RegenerateShareableLinkId",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.regenerateShareableLinkId(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/TravelAssetSuggestionService
     */
    get travelAssetSuggestions() {
        const service = this.loadService("TravelAssetSuggestionServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/TravelAssetSuggestionService#suggesttravelassets
             */
            suggestTravelAssets: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "TravelAssetSuggestionService.SuggestTravelAssets",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.suggestTravelAssets(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/UserDataService
     */
    get userData() {
        const service = this.loadService("UserDataServiceClient");
        return {
            /**
             * @link https://developers.google.com/google-ads/api/reference/rpc/v21/UserDataService#uploaduserdata
             */
            uploadUserData: async (request) => {
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserDataService.UploadUserData",
                    requestOptions: request,
                };
                if (this.hooks.onServiceStart) {
                    const serviceCancellation = { cancelled: false };
                    await this.hooks.onServiceStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            serviceCancellation.cancelled = true;
                            serviceCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (serviceCancellation.cancelled) {
                        return serviceCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.uploadUserData(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onServiceEnd) {
                        const serviceResolution = { resolved: false };
                        await this.hooks.onServiceEnd({
                            ...baseHookArguments,
                            response,
                            resolve: (res) => {
                                serviceResolution.resolved = true;
                                serviceResolution.res = res;
                            },
                        });
                        if (serviceResolution.resolved) {
                            return serviceResolution.res;
                        }
                    }
                    return response;
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onServiceError) {
                        await this.hooks.onServiceError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
    /**
     * @link https://developers.google.com/google-ads/api/reference/rpc/v21/UserListCustomerTypeService
     */
    get userListCustomerTypes() {
        const service = this.loadService("UserListCustomerTypeServiceClient");
        return {
            /**
             * @description create resources of type resources.IUserListCustomerType
             * @returns services.MutateUserListCustomerTypesResponse
             */
            create: async (userListCustomerTypes, options) => {
                const ops = this.buildOperations("create", userListCustomerTypes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListCustomerTypeService.mutateUserListCustomerTypes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserListCustomerTypes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
            /**
             * @description remove resources of type string
             * @returns services.MutateUserListCustomerTypesResponse
             */
            remove: async (userListCustomerTypes, options) => {
                const ops = this.buildOperations("remove", userListCustomerTypes);
                const request = this.buildRequest(ops, options);
                const baseHookArguments = {
                    credentials: this.credentials,
                    method: "UserListCustomerTypeService.mutateUserListCustomerTypes",
                    mutation: request,
                    isServiceCall: true,
                };
                if (this.hooks.onMutationStart) {
                    const mutationCancellation = { cancelled: false };
                    await this.hooks.onMutationStart({
                        ...baseHookArguments,
                        cancel: (res) => {
                            mutationCancellation.cancelled = true;
                            mutationCancellation.res = res;
                        },
                        editOptions: (options) => {
                            Object.entries(options).forEach(([key, val]) => {
                                // @ts-expect-error Index with key type is fine
                                request[key] = val;
                            });
                        },
                    });
                    if (mutationCancellation.cancelled) {
                        return mutationCancellation.res;
                    }
                }
                try {
                    // @ts-expect-error Response is an array type
                    const [response] = await service.mutateUserListCustomerTypes(request, {
                        // @ts-expect-error This arg doesn't exist in the type definitions
                        otherArgs: {
                            headers: this.callHeaders,
                        },
                    });
                    if (this.hooks.onMutationEnd) {
                        const mutationResolution = { resolved: false };
                        await this.hooks.onMutationEnd({
                            ...baseHookArguments,
                            response: this.decodePartialFailureError(response),
                            resolve: (res) => {
                                mutationResolution.resolved = true;
                                mutationResolution.res = res;
                            },
                        });
                        if (mutationResolution.resolved) {
                            return mutationResolution.res;
                        }
                    }
                    return this.decodePartialFailureError(response);
                }
                catch (err) {
                    const googleAdsError = this.getGoogleAdsError(err);
                    if (this.hooks.onMutationError) {
                        await this.hooks.onMutationError({
                            ...baseHookArguments,
                            error: googleAdsError,
                        });
                    }
                    throw googleAdsError;
                }
            },
        };
    }
}
exports.default = ServiceFactory;
